"use strict";

exports.__esModule = true;
exports.classDeclaration = exports.typeReference = exports.enumDeclaration = exports.typeDeclaration = exports.interfaceDeclaration = exports.interfaceType = exports.variableDeclaration = exports.propertyDeclaration = void 0;

var ts = _interopRequireWildcard(require("typescript"));

var _options = require("../options");

var _checker = require("../checker");

var _index = _interopRequireDefault(require("./index"));

var _env = require("../env");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const propertyDeclaration = (node, keywordPrefix, isVar = false) => {
  let left = keywordPrefix;

  const symbol = _checker.checker.current.getSymbolAtLocation(node.name);

  const name = isVar ? _index.default.node.getFullyQualifiedName(symbol, node.name) : _index.default.node.printType(node.name);

  if (node.modifiers && node.modifiers.some(modifier => modifier.kind === ts.SyntaxKind.PrivateKeyword)) {
    return "";
  }

  if (node.modifiers && node.modifiers.some(modifier => modifier.kind === ts.SyntaxKind.ReadonlyKeyword)) {
    left += "+";
  }

  left += name;

  if (node.parameters) {
    return left + ": " + node.parameters.map(_index.default.common.parameter);
  }

  if (node.type) {
    let right = _index.default.node.printType(node.type);

    if (node.questionToken && node.name.kind !== ts.SyntaxKind.ComputedPropertyName) {
      left += "?";
    }

    if (node.questionToken && node.name.kind === ts.SyntaxKind.ComputedPropertyName) {
      right = `(${right}) | void`;
    }

    return left + ": " + right;
  }

  return left + `: any // ${_index.default.node.printType(node.initializer)}\n`;
};

exports.propertyDeclaration = propertyDeclaration;

const variableDeclaration = node => {
  const declarations = node.declarationList.declarations.map(_index.default.node.printType);
  return declarations.map(name => `declare ${_index.default.relationships.exporter(node)}var ${name};`).join("\n");
};

exports.variableDeclaration = variableDeclaration;

const interfaceType = (node, withSemicolons = false, isType = false) => {
  const isInexact = (0, _options.opts)().inexact;
  let members = node.members.map(member => {
    const printed = _index.default.node.printType(member);

    if (!printed) {
      return null;
    }

    let str = "\n";

    if (member.jsDoc) {
      str += _index.default.common.comment(member.jsDoc);
    }

    return str + printed;
  });

  if (isType && isInexact) {
    members.push("...\n");
  } else if (members.length > 0) {
    members.push("\n");
  }

  return `{${members.filter(Boolean) // Filter rows which didnt print propely (private fields et al)
  .join(withSemicolons ? ";" : ",")}}`;
};

exports.interfaceType = interfaceType;

const interfaceRecordType = (node, heritage, withSemicolons = false) => {
  let members = node.members.map(member => {
    const printed = _index.default.node.printType(member);

    if (!printed) {
      return null;
    }

    let str = "\n";

    if (member.jsDoc) {
      str += _index.default.common.comment(member.jsDoc);
    }

    return str + printed;
  }).filter(Boolean) // Filter rows which didnt print propely (private fields et al)
  .join(withSemicolons ? ";" : ",");

  if (members.length > 0) {
    members += "\n";
  }

  return `{${heritage}${members}}`;
};

const classHeritageClause = (0, _env.withEnv)((env, type) => {
  let ret;
  env.classHeritage = true; // TODO: refactor this

  const symbol = _checker.checker.current.getSymbolAtLocation(type.expression);

  _index.default.node.fixDefaultTypeArguments(symbol, type);

  if (type.expression.kind === ts.SyntaxKind.Identifier && symbol) {
    ret = _index.default.node.getFullyQualifiedPropertyAccessExpression(symbol, type.expression) + _index.default.common.generics(type.typeArguments);
  } else {
    ret = _index.default.node.printType(type);
  }

  env.classHeritage = false;
  return ret;
});

const interfaceHeritageClause = type => {
  // TODO: refactor this
  const symbol = _checker.checker.current.getSymbolAtLocation(type.expression);

  _index.default.node.fixDefaultTypeArguments(symbol, type);

  if (type.expression.kind === ts.SyntaxKind.Identifier && symbol) {
    const name = _index.default.node.getFullyQualifiedPropertyAccessExpression(symbol, type.expression);

    return name + _index.default.common.generics(type.typeArguments);
  } else if (type.expression.kind === ts.SyntaxKind.Identifier) {
    const name = _index.default.identifiers.print(type.expression.text);

    if (typeof name === "function") {
      return name(type.typeArguments);
    }
  } else {
    return _index.default.node.printType(type);
  }
};

const interfaceRecordDeclaration = (nodeName, node, modifier) => {
  let heritage = ""; // If the class is extending something

  if (node.heritageClauses) {
    heritage = node.heritageClauses.map(clause => {
      return clause.types.map(interfaceHeritageClause).map(type => `...$Exact<${type}>`).join(",\n");
    }).join("");
    heritage = heritage.length > 0 ? `${heritage},\n` : "";
  }

  let str = `${modifier}type ${nodeName}${_index.default.common.generics(node.typeParameters)} = ${interfaceRecordType(node, heritage)}\n`;
  return str;
};

const interfaceDeclaration = (nodeName, node, modifier) => {
  const isRecord = (0, _options.opts)().interfaceRecords;

  if (isRecord) {
    return interfaceRecordDeclaration(nodeName, node, modifier);
  }

  let heritage = ""; // If the class is extending something

  if (node.heritageClauses) {
    heritage = node.heritageClauses.map(clause => {
      return clause.types.map(interfaceHeritageClause).join(" & ");
    }).join("");
    heritage = heritage.length > 0 ? `& ${heritage}\n` : "";
  }

  const type = node.heritageClauses ? "type" : "interface";
  let str = `${modifier}${type} ${nodeName}${_index.default.common.generics(node.typeParameters)} ${type === "type" ? "= " : ""}${interfaceType(node, false, type === "type")} ${heritage}`;
  return str;
};

exports.interfaceDeclaration = interfaceDeclaration;

const typeDeclaration = (nodeName, node, modifier) => {
  let str = `${modifier}type ${nodeName}${_index.default.common.generics(node.typeParameters)} = ${_index.default.node.printType(node.type)};`;
  return str;
};

exports.typeDeclaration = typeDeclaration;

const enumDeclaration = (nodeName, node) => {
  const exporter = _index.default.relationships.exporter(node);

  let members = "";

  for (const [index, member] of node.members.entries()) {
    let value;

    if (typeof member.initializer !== "undefined") {
      value = _index.default.node.printType(member.initializer);
    } else {
      value = index;
    }

    members += `+${member.name.text}: ${value},`;
    members += `// ${value}\n`;
  }

  return `
declare ${exporter} var ${nodeName}: {|
  ${members}
|};\n`;
};

exports.enumDeclaration = enumDeclaration;

const typeReference = (node, identifier) => {
  if (node.typeName.left && node.typeName.right) {
    return _index.default.node.printType(node.typeName) + _index.default.common.generics(node.typeArguments);
  }

  let name = node.typeName.text;

  if (identifier) {
    name = _index.default.identifiers.print(node.typeName.text);

    if (typeof name === "function") {
      return name(node.typeArguments);
    }
  }

  return _index.default.relationships.namespaceProp(name) + _index.default.common.generics(node.typeArguments);
};

exports.typeReference = typeReference;

const classDeclaration = (nodeName, node) => {
  let heritage = ""; // If the class is extending something

  if (node.heritageClauses) {
    heritage = node.heritageClauses.map(clause => {
      return clause.types.map(classHeritageClause).join(", ");
    }).join(", ");
    heritage = heritage.length > 0 ? `mixins ${heritage}` : "";
  }

  let str = `declare ${_index.default.relationships.exporter(node)}class ${nodeName}${_index.default.common.generics(node.typeParameters)} ${heritage} ${interfaceType(node, true)}`;
  return str;
};

exports.classDeclaration = classDeclaration;