"use strict";

exports.__esModule = true;
exports.recursiveWalkTree = recursiveWalkTree;

var ts = _interopRequireWildcard(require("typescript"));

var _node = _interopRequireDefault(require("../nodes/node"));

var _factory = _interopRequireDefault(require("../nodes/factory"));

var _namespaceManager = _interopRequireDefault(require("../namespace-manager"));

var _ast = require("./ast");

var logger = _interopRequireWildcard(require("../logger"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const collectNode = (node, context, factory) => {
  (0, _ast.stripDetailsFromTree)(node);

  switch (node.kind) {
    case ts.SyntaxKind.ModuleDeclaration:
      if (node.flags === 4098 || (node.flags & ts.NodeFlags.Namespace) === ts.NodeFlags.Namespace) {
        if ((node.flags & ts.NodeFlags.GlobalAugmentation) === ts.NodeFlags.GlobalAugmentation) {
          logger.error(node, {
            type: "UnsupportedGlobalAugmentation"
          });
          const globalAugmentation = factory.createModuleNode(node, node.name.text);
          context.addChild("module" + node.name.text, globalAugmentation);
          traverseNode(node.body, globalAugmentation, factory);
          break;
        }

        const namespace = factory.createNamespaceNode(node, node.name.text, context);

        _namespaceManager.default.setContext(node.name.text);

        traverseNode(node.body, namespace, factory);
        context.addChildren("namespace" + node.name.text, namespace);
        break;
      } else {
        const module = factory.createModuleNode(node, node.name.text);
        context.addChild("module" + node.name.text, module);
        traverseNode(node.body, module, factory);
        break;
      }

    case ts.SyntaxKind.FunctionDeclaration:
      // TODO: rewrite this
      factory.createFunctionDeclaration(node, (0, _ast.parseNameFromNode)(node), context);
      break;

    case ts.SyntaxKind.InterfaceDeclaration:
      context.addChild((0, _ast.parseNameFromNode)(node), factory.createPropertyNode(node, (0, _ast.parseNameFromNode)(node), context));
      break;

    case ts.SyntaxKind.TypeAliasDeclaration:
      context.addChild((0, _ast.parseNameFromNode)(node), factory.createPropertyNode(node, (0, _ast.parseNameFromNode)(node), context));
      break;

    case ts.SyntaxKind.ClassDeclaration:
      context.addChild((0, _ast.parseNameFromNode)(node), factory.createPropertyNode(node));
      break;

    case ts.SyntaxKind.VariableStatement:
      context.addChild((0, _ast.parseNameFromNode)(node), factory.createPropertyNode(node));
      break;

    case ts.SyntaxKind.ExportAssignment:
      context.addChild("exportassign" + (0, _ast.parseNameFromNode)(node), factory.createExportNode(node));
      break;

    case ts.SyntaxKind.ImportDeclaration:
      context.addChild((0, _ast.parseNameFromNode)(node), factory.createImportNode(node));
      break;

    case ts.SyntaxKind.ExportDeclaration:
      context.addChild("exportdecl" + (0, _ast.parseNameFromNode)(node), factory.createExportDeclarationNode(node));
      break;

    case ts.SyntaxKind.ImportEqualsDeclaration:
      // see transformers
      break;

    case ts.SyntaxKind.NamespaceExportDeclaration:
      // TODO: unimplemented;
      break;

    case ts.SyntaxKind.EnumDeclaration:
      context.addChild((0, _ast.parseNameFromNode)(node), factory.createPropertyNode(node));
      break;

    case ts.SyntaxKind.EmptyStatement:
      // This should be empty
      break;

    default:
      console.log("Missing node parse", ts.SyntaxKind[node.kind]);
  }
}; // Walk the AST and extract all the definitions we care about


const traverseNode = (node, context, factory) => {
  if (!node.statements) {
    collectNode(node, context, factory);
  } else {
    node.statements.forEach(n => collectNode(n, context, factory));
  }
};

function recursiveWalkTree(ast) {
  const factory = _factory.default.create();

  const root = factory.createModuleNode(null, "root");
  traverseNode(ast, root, factory);
  return root;
}