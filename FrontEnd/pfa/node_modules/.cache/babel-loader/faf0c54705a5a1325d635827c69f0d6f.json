{"ast":null,"code":"/**\r\n * @module  string-to-arraybuffer\r\n */\n'use strict';\n\nvar atob = require('atob-lite');\n\nvar isBase64 = require('is-base64');\n\nmodule.exports = function stringToArrayBuffer(arg) {\n  if (typeof arg !== 'string') throw Error('Argument should be a string'); //valid data uri\n\n  if (/^data\\:/i.test(arg)) return decode(arg); //base64\n\n  if (isBase64(arg)) arg = atob(arg);\n  return str2ab(arg);\n};\n\nfunction str2ab(str) {\n  var array = new Uint8Array(str.length);\n\n  for (var i = 0; i < str.length; i++) {\n    array[i] = str.charCodeAt(i);\n  }\n\n  return array.buffer;\n}\n\nfunction decode(uri) {\n  // strip newlines\n  uri = uri.replace(/\\r?\\n/g, ''); // split the URI up into the \"metadata\" and the \"data\" portions\n\n  var firstComma = uri.indexOf(',');\n  if (-1 === firstComma || firstComma <= 4) throw new TypeError('malformed data-URI'); // remove the \"data:\" scheme and parse the metadata\n\n  var meta = uri.substring(5, firstComma).split(';');\n  var base64 = false;\n  var charset = 'US-ASCII';\n\n  for (var i = 0; i < meta.length; i++) {\n    if ('base64' == meta[i]) {\n      base64 = true;\n    } else if (0 == meta[i].indexOf('charset=')) {\n      charset = meta[i].substring(8);\n    }\n  } // get the encoded data portion and decode URI-encoded chars\n\n\n  var data = unescape(uri.substring(firstComma + 1));\n  if (base64) data = atob(data);\n  var abuf = str2ab(data);\n  abuf.type = meta[0] || 'text/plain';\n  abuf.charset = charset;\n  return abuf;\n}","map":{"version":3,"sources":["E:/Projetos/Portal/PF/EBK_PF_Adm/FrontEnd/pfa/node_modules/string-to-arraybuffer/index.js"],"names":["atob","require","isBase64","module","exports","stringToArrayBuffer","arg","Error","test","decode","str2ab","str","array","Uint8Array","length","i","charCodeAt","buffer","uri","replace","firstComma","indexOf","TypeError","meta","substring","split","base64","charset","data","unescape","abuf","type"],"mappings":"AAAA;;;AAIA;;AAEA,IAAIA,IAAI,GAAGC,OAAO,CAAC,WAAD,CAAlB;;AACA,IAAIC,QAAQ,GAAGD,OAAO,CAAC,WAAD,CAAtB;;AAEAE,MAAM,CAACC,OAAP,GAAiB,SAASC,mBAAT,CAA8BC,GAA9B,EAAmC;AACnD,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B,MAAMC,KAAK,CAAC,6BAAD,CAAX,CADsB,CAGnD;;AACA,MAAI,WAAWC,IAAX,CAAgBF,GAAhB,CAAJ,EAA0B,OAAOG,MAAM,CAACH,GAAD,CAAb,CAJyB,CAMnD;;AACA,MAAIJ,QAAQ,CAACI,GAAD,CAAZ,EAAmBA,GAAG,GAAGN,IAAI,CAACM,GAAD,CAAV;AAEnB,SAAOI,MAAM,CAACJ,GAAD,CAAb;AACA,CAVD;;AAYA,SAASI,MAAT,CAAiBC,GAAjB,EAAsB;AACrB,MAAIC,KAAK,GAAG,IAAIC,UAAJ,CAAeF,GAAG,CAACG,MAAnB,CAAZ;;AACA,OAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGJ,GAAG,CAACG,MAAvB,EAA+BC,CAAC,EAAhC,EAAoC;AACnCH,IAAAA,KAAK,CAACG,CAAD,CAAL,GAAWJ,GAAG,CAACK,UAAJ,CAAeD,CAAf,CAAX;AACA;;AACD,SAAOH,KAAK,CAACK,MAAb;AACA;;AAED,SAASR,MAAT,CAAgBS,GAAhB,EAAqB;AACpB;AACAA,EAAAA,GAAG,GAAGA,GAAG,CAACC,OAAJ,CAAY,QAAZ,EAAsB,EAAtB,CAAN,CAFoB,CAIpB;;AACA,MAAIC,UAAU,GAAGF,GAAG,CAACG,OAAJ,CAAY,GAAZ,CAAjB;AACA,MAAI,CAAC,CAAD,KAAOD,UAAP,IAAqBA,UAAU,IAAI,CAAvC,EAA0C,MAAM,IAAIE,SAAJ,CAAc,oBAAd,CAAN,CANtB,CAQpB;;AACA,MAAIC,IAAI,GAAGL,GAAG,CAACM,SAAJ,CAAc,CAAd,EAAiBJ,UAAjB,EAA6BK,KAA7B,CAAmC,GAAnC,CAAX;AAEA,MAAIC,MAAM,GAAG,KAAb;AACA,MAAIC,OAAO,GAAG,UAAd;;AACA,OAAK,IAAIZ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGQ,IAAI,CAACT,MAAzB,EAAiCC,CAAC,EAAlC,EAAsC;AACrC,QAAI,YAAYQ,IAAI,CAACR,CAAD,CAApB,EAAyB;AACxBW,MAAAA,MAAM,GAAG,IAAT;AACA,KAFD,MAEO,IAAI,KAAKH,IAAI,CAACR,CAAD,CAAJ,CAAQM,OAAR,CAAgB,UAAhB,CAAT,EAAsC;AAC5CM,MAAAA,OAAO,GAAGJ,IAAI,CAACR,CAAD,CAAJ,CAAQS,SAAR,CAAkB,CAAlB,CAAV;AACA;AACD,GAnBmB,CAqBpB;;;AACA,MAAII,IAAI,GAAGC,QAAQ,CAACX,GAAG,CAACM,SAAJ,CAAcJ,UAAU,GAAG,CAA3B,CAAD,CAAnB;AAEA,MAAIM,MAAJ,EAAYE,IAAI,GAAG5B,IAAI,CAAC4B,IAAD,CAAX;AAEZ,MAAIE,IAAI,GAAGpB,MAAM,CAACkB,IAAD,CAAjB;AAEAE,EAAAA,IAAI,CAACC,IAAL,GAAYR,IAAI,CAAC,CAAD,CAAJ,IAAW,YAAvB;AACAO,EAAAA,IAAI,CAACH,OAAL,GAAeA,OAAf;AAEA,SAAOG,IAAP;AACA","sourcesContent":["/**\r\n * @module  string-to-arraybuffer\r\n */\r\n\r\n'use strict'\r\n\r\nvar atob = require('atob-lite')\r\nvar isBase64 = require('is-base64')\r\n\r\nmodule.exports = function stringToArrayBuffer (arg) {\r\n\tif (typeof arg !== 'string') throw Error('Argument should be a string')\r\n\r\n\t//valid data uri\r\n\tif (/^data\\:/i.test(arg)) return decode(arg)\r\n\r\n\t//base64\r\n\tif (isBase64(arg)) arg = atob(arg)\r\n\r\n\treturn str2ab(arg)\r\n}\r\n\r\nfunction str2ab (str) {\r\n\tvar array = new Uint8Array(str.length);\r\n\tfor(var i = 0; i < str.length; i++) {\r\n\t\tarray[i] = str.charCodeAt(i);\r\n\t}\r\n\treturn array.buffer\r\n}\r\n\r\nfunction decode(uri) {\r\n\t// strip newlines\r\n\turi = uri.replace(/\\r?\\n/g, '');\r\n\r\n\t// split the URI up into the \"metadata\" and the \"data\" portions\r\n\tvar firstComma = uri.indexOf(',');\r\n\tif (-1 === firstComma || firstComma <= 4) throw new TypeError('malformed data-URI');\r\n\r\n\t// remove the \"data:\" scheme and parse the metadata\r\n\tvar meta = uri.substring(5, firstComma).split(';');\r\n\r\n\tvar base64 = false;\r\n\tvar charset = 'US-ASCII';\r\n\tfor (var i = 0; i < meta.length; i++) {\r\n\t\tif ('base64' == meta[i]) {\r\n\t\t\tbase64 = true;\r\n\t\t} else if (0 == meta[i].indexOf('charset=')) {\r\n\t\t\tcharset = meta[i].substring(8);\r\n\t\t}\r\n\t}\r\n\r\n\t// get the encoded data portion and decode URI-encoded chars\r\n\tvar data = unescape(uri.substring(firstComma + 1));\r\n\r\n\tif (base64) data = atob(data)\r\n\r\n\tvar abuf = str2ab(data)\r\n\r\n\tabuf.type = meta[0] || 'text/plain'\r\n\tabuf.charset = charset\r\n\r\n\treturn abuf\r\n}\r\n"]},"metadata":{},"sourceType":"script"}