{"ast":null,"code":"/**\r\n * @module  to-array-buffer\r\n */\n'use strict';\n\nvar str2ab = require('string-to-arraybuffer');\n\nvar flat = require('flatten-vertex-data'); // var isBlob = require('is-blob')\n\n\nmodule.exports = function toArrayBuffer(arg) {\n  //zero-length or undefined-like\n  if (!arg) return null; //array buffer\n\n  if (arg instanceof ArrayBuffer) return arg; //try to decode data-uri\n\n  if (typeof arg === 'string') {\n    return str2ab(arg);\n  } // File & Blob\n  // if (isBlob(src) || (src instanceof global.File)) {\n  // FIXME: we cannot use it here bc FileReader is async\n  // }\n  //array buffer view: TypedArray, DataView, Buffer etc\n\n\n  if (ArrayBuffer.isView(arg)) {\n    // if byteOffset is not 0, return sub-reference (slice is the only way)\n    if (arg.byteOffset) {\n      return arg.buffer.slice(arg.byteOffset, arg.byteOffset + arg.byteLength);\n    }\n\n    return arg.buffer;\n  } //buffer/data nested: NDArray, ImageData etc.\n  //FIXME: NDArrays with custom data type may be invalid for this procedure\n\n\n  if (arg.buffer || arg.data || arg._data) {\n    var result = toArrayBuffer(arg.buffer || arg.data || arg._data);\n    return result;\n  } // detect if flat\n\n\n  if (Array.isArray(arg)) {\n    for (var i = 0; i < arg.length; i++) {\n      if (arg[i].length != null) {\n        arg = flat(arg);\n        break;\n      }\n    }\n  } //array-like or unknown\n  //consider Uint8Array knows how to treat the input\n\n\n  var result = new Uint8Array(arg);\n  if (!result.length) return null;\n  return result.buffer;\n};","map":{"version":3,"sources":["E:/Projetos/Portal/PF/EBK_PF_Adm/FrontEnd/pfa/node_modules/to-array-buffer/index.js"],"names":["str2ab","require","flat","module","exports","toArrayBuffer","arg","ArrayBuffer","isView","byteOffset","buffer","slice","byteLength","data","_data","result","Array","isArray","i","length","Uint8Array"],"mappings":"AAAA;;;AAIA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,uBAAD,CAApB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,qBAAD,CAAlB,C,CACA;;;AAGAE,MAAM,CAACC,OAAP,GAAiB,SAASC,aAAT,CAAwBC,GAAxB,EAA6B;AAC7C;AACA,MAAI,CAACA,GAAL,EAAU,OAAO,IAAP,CAFmC,CAI7C;;AACA,MAAIA,GAAG,YAAYC,WAAnB,EAAgC,OAAOD,GAAP,CALa,CAO7C;;AACA,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC5B,WAAON,MAAM,CAACM,GAAD,CAAb;AACA,GAV4C,CAY7C;AACA;AACC;AACD;AAEA;;;AACA,MAAIC,WAAW,CAACC,MAAZ,CAAmBF,GAAnB,CAAJ,EAA6B;AAC5B;AACA,QAAIA,GAAG,CAACG,UAAR,EAAoB;AACnB,aAAOH,GAAG,CAACI,MAAJ,CAAWC,KAAX,CAAiBL,GAAG,CAACG,UAArB,EAAiCH,GAAG,CAACG,UAAJ,GAAiBH,GAAG,CAACM,UAAtD,CAAP;AACA;;AACD,WAAON,GAAG,CAACI,MAAX;AACA,GAxB4C,CA0B7C;AACA;;;AACA,MAAIJ,GAAG,CAACI,MAAJ,IAAcJ,GAAG,CAACO,IAAlB,IAA0BP,GAAG,CAACQ,KAAlC,EAAyC;AACxC,QAAIC,MAAM,GAAGV,aAAa,CAACC,GAAG,CAACI,MAAJ,IAAcJ,GAAG,CAACO,IAAlB,IAA0BP,GAAG,CAACQ,KAA/B,CAA1B;AACA,WAAOC,MAAP;AACA,GA/B4C,CAiC7C;;;AACA,MAAIC,KAAK,CAACC,OAAN,CAAcX,GAAd,CAAJ,EAAwB;AACvB,SAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,GAAG,CAACa,MAAxB,EAAgCD,CAAC,EAAjC,EAAqC;AACpC,UAAIZ,GAAG,CAACY,CAAD,CAAH,CAAOC,MAAP,IAAiB,IAArB,EAA2B;AAC1Bb,QAAAA,GAAG,GAAGJ,IAAI,CAACI,GAAD,CAAV;AACA;AACA;AACD;AACD,GAzC4C,CA2C7C;AACA;;;AACA,MAAIS,MAAM,GAAG,IAAIK,UAAJ,CAAed,GAAf,CAAb;AAEA,MAAI,CAACS,MAAM,CAACI,MAAZ,EAAoB,OAAO,IAAP;AACpB,SAAOJ,MAAM,CAACL,MAAd;AACA,CAjDD","sourcesContent":["/**\r\n * @module  to-array-buffer\r\n */\r\n\r\n'use strict'\r\n\r\nvar str2ab = require('string-to-arraybuffer')\r\nvar flat = require('flatten-vertex-data')\r\n// var isBlob = require('is-blob')\r\n\r\n\r\nmodule.exports = function toArrayBuffer (arg) {\r\n\t//zero-length or undefined-like\r\n\tif (!arg) return null\r\n\r\n\t//array buffer\r\n\tif (arg instanceof ArrayBuffer) return arg\r\n\r\n\t//try to decode data-uri\r\n\tif (typeof arg === 'string') {\r\n\t\treturn str2ab(arg)\r\n\t}\r\n\r\n\t// File & Blob\r\n\t// if (isBlob(src) || (src instanceof global.File)) {\r\n\t\t// FIXME: we cannot use it here bc FileReader is async\r\n\t// }\r\n\r\n\t//array buffer view: TypedArray, DataView, Buffer etc\r\n\tif (ArrayBuffer.isView(arg)) {\r\n\t\t// if byteOffset is not 0, return sub-reference (slice is the only way)\r\n\t\tif (arg.byteOffset) {\r\n\t\t\treturn arg.buffer.slice(arg.byteOffset, arg.byteOffset + arg.byteLength)\r\n\t\t}\r\n\t\treturn arg.buffer\r\n\t}\r\n\r\n\t//buffer/data nested: NDArray, ImageData etc.\r\n\t//FIXME: NDArrays with custom data type may be invalid for this procedure\r\n\tif (arg.buffer || arg.data || arg._data) {\r\n\t\tvar result = toArrayBuffer(arg.buffer || arg.data || arg._data)\r\n\t\treturn result\r\n\t}\r\n\r\n\t// detect if flat\r\n\tif (Array.isArray(arg)) {\r\n\t\tfor (var i = 0; i < arg.length; i++) {\r\n\t\t\tif (arg[i].length != null) {\r\n\t\t\t\targ = flat(arg)\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//array-like or unknown\r\n\t//consider Uint8Array knows how to treat the input\r\n\tvar result = new Uint8Array(arg)\r\n\r\n\tif (!result.length) return null\r\n\treturn result.buffer\r\n}\r\n"]},"metadata":{},"sourceType":"script"}